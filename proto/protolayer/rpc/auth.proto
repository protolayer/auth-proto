syntax = "proto3";

package protolayer.rpc;

import "google/protobuf/descriptor.proto";

option go_package = "buf.build/gen/go/protolayer/rpcauth/protocolbuffers/go/protolayer/rpc";

// Note, the rules are unregistered. Using a sufficiently high number to avoid conflicts with other
// fields that are in the lower ranges.
//
// See https://github.com/protocolbuffers/protobuf/blob/v28.3/docs/options.md for more information.
//
// I hope to get a range of 10 numbers to work with, which should be enough for the foreseeable
// future.

// Service-level options for configuring authentication, authorization, and rate limiting.
extend google.protobuf.ServiceOptions {
  // Authentication configuration for all RPCs in the service.
  optional AuthRule service_auth = 1300;
  // Authorization configuration for all RPCs in the service.
  optional AccessRule service_access = 1301;
  // Rate limiting configuration for all RPCs in the service.
  optional RateRule service_limit = 1302;
}

// Method-level options for configuring authentication, authorization, and rate limiting. These
// options always take precedence over their service-level counterparts, allowing methods to
// override service defaults.
extend google.protobuf.MethodOptions {
  // Authentication configuration (who are you?).
  optional AuthRule method_auth = 1303;
  // Authorization configuration (what can you do?).
  optional AccessRule method_access = 1304;
  // Rate limiting configuration (how often can you do it?).
  optional RateRule method_rate = 1305;
}

// Add field-level extension for privacy rules.
extend google.protobuf.FieldOptions {
  // Controls field visibility and access.
  optional PrivacyRule privacy = 1306;
}

// Authentication configuration for the RPC method or service.
message AuthRule {
  // Mode of authentication.
  AuthMode mode = 1;
}

// Different modes of authentication.
enum AuthMode {
  AUTH_UNSPECIFIED = 0;
  // Public endpoint, no authentication required.
  PUBLIC = 1;
  // Authentication required to access endpoint.
  REQUIRED = 2;
}

// Access control configuration using Hybrid RBAC (roles and permissions).
message AccessRule {
  // List of rule sets, where any single rule set grants access (OR relationship). Access is granted
  // if ANY rule set passes. This allows for different combinations of roles/permissions that can
  // grant access.
  repeated RuleSet rules = 1;
}

// A set of roles and permissions that together grant access. All roles and permissions within a set
// must match (AND relationship).
//
// Examples:
//   - roles: ["admin"] AND permissions: ["delete"]
//   - roles: ["support", "manager"] AND permissions: ["view", "update"]
//     - (must have BOTH roles AND BOTH permissions)
message RuleSet {
  // Required roles for this rule set.
  repeated string roles = 1;
  // Required permissions for this rule set.
  repeated string permissions = 2;
}

// Rate limiting configuration for an RPC method.
message RateRule {
  // What to use as the rate limit key.
  LimitBy key = 1;
  // Roles that bypass rate limiting entirely.
  repeated string bypass_roles = 2;
  // Rate limiting algorithm configuration.
  oneof algorithm {
    // Leaky bucket configuration.
    LeakyBucket leaky_bucket = 3;

    // Add more rate limiting algorithms here. For example, token bucket, fixed window, etc.
  }
}

// Different types of rate limit keys.
enum LimitBy {
  LIMIT_UNSPECIFIED = 0;
  // Limit by client IP address.
  IP = 1;
  // Limit by authenticated user.
  USER = 2;
  // Limit by API key.
  //
  // This is useful for limiting the number of requests per API key. Less permissive than USER,
  // which is based on the authenticated user instead of the API key.
  API_KEY = 3;
  // Global limit across all requests.
  //
  // This is useful for limiting the total number of requests to a service, regardless of the
  // client. For example, a service may want to limit the total number of requests to 1000 per
  // second. This is different from the other types of rate limiting, which are per client.
  GLOBAL = 4;
}

// Leaky bucket rate limiting configuration.
message LeakyBucket {
  // Maximum burst capacity (bucket size).
  uint32 burst_capacity = 1;
  // Number of requests allowed.
  uint32 rate_requests = 2;
  // Time window in seconds.
  uint32 rate_seconds = 3;
}

// PrivacyRule controls field visibility and access.
message PrivacyRule {
  // Behavior when accessing field from unauthorized context.
  PrivacyMode mode = 1;
  // Specific roles that can access the field. If empty, all authenticated users can access.
  repeated string visible_to_roles = 2;
}

// PrivacyMode is used to determine how to handle sensitive fields.
enum PrivacyMode {
  PRIVACY_UNSPECIFIED = 0;
  // Field is not sensitive and can be returned in the response.
  VISIBLE = 1;
  // Field is sensitive and should be omitted from the response.
  OMIT = 2;
  // Field is sensitive and should be redacted from the response (replaced with a configurable
  // placeholder value).
  REDACT = 3;
}
